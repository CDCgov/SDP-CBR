package org.cdc.gov.sdp.phinms;

import java.sql.Blob;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.List;
import java.util.regex.Pattern;

import javax.sql.DataSource;

import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

import com.google.common.base.CharMatcher;
import com.google.common.base.Splitter;

public class PhinMSProducer extends DefaultProducer {

	private static Logger logger = LogManager.getLogger("PhinMsInsert");

	private DataSource phinMsDs;
	private String tableName = "message_inq";

	private String phinMsInsertSql;
	private Connection connection;
	private PreparedStatement insertSql;

	public PhinMSProducer(Endpoint endpoint, String uri, DataSource ds, String tableName) {
		super(endpoint);

		this.phinMsDs = ds;
		this.tableName = tableName;
		phinMsInsertSql = "insert into " + tableName + " ";
	}

	@Override
	public PhinMSEndpoint getEndpoint() {
		return (PhinMSEndpoint) super.getEndpoint();
	}

	@Override
	public void process(final Exchange exchange) throws Exception {
		try {
			if (connection == null) {
				connection = phinMsDs.getConnection();
			}

			List<String> separated = Splitter.on(CharMatcher.anyOf("\n\r")).omitEmptyStrings()
					.splitToList((String) exchange.getIn().getBody());

			if (separated.size() == 0) {
				logger.error("No contents in file.");
				return;
			}

			String headers = separated.get(0);

			Splitter csvSplit = Splitter.on(Pattern.compile(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)"));
			List<String> headerArr = csvSplit.splitToList(headers);

			String sqlColumns = "";
			String sqlFields = "";
			int columnCount = 0;
			for (String header : headerArr) {
				sqlColumns = sqlColumns + header + (columnCount == headerArr.size() - 1 ? "" : ", ");
				sqlFields = sqlFields + "?" + (columnCount == headerArr.size() - 1 ? "" : ", ");
				columnCount++;
			}

			if (insertSql == null) {
				insertSql = connection
						.prepareStatement(phinMsInsertSql + " (" + sqlColumns + ") values (" + sqlFields + ")");
			}

			for (int i = 1; i < separated.size(); i++) {
				List<String> values = csvSplit.splitToList(separated.get(i));

				for (int j = 0; j < values.size(); j++) {
					switch (headerArr.get(j)) {
					case "recordId": // Should not be used in most cases -
										// autogenerated.
						insertSql.setLong(j + 1, Long.parseLong(values.get(j)));
						break;
					case "payloadBinaryContent":
						Blob blob = connection.createBlob();
						blob.setBytes(1, values.get(j).getBytes());
						insertSql.setBlob(j + 1, blob);
						break;
					case "payloadTextContent":
						insertSql.setString(j + 1, values.get(j));
						break;
					default:
						insertSql.setString(j + 1, values.get(j));
					}
				}
				insertSql.addBatch();
			}

			insertSql.executeBatch();
		} catch (Exception e) {
			logger.error("An error occured when attempting to write to Phin-MS");
			e.printStackTrace();
		}
	}
}
